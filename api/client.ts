/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export interface ISandboxClient {
    /**
     * Регистрация клиента в sandbox
     * @param body (optional) Запрос на создание счета и выставление баланса по валютным позициям
     * @return Успешный ответ
     */
    register(body?: SandboxRegisterRequest | undefined): Promise<SandboxRegisterResponse>;
    /**
     * Выставление баланса по валютным позициям
     * @param body Запрос на выставление баланса по валютным позициям
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    balance(body: SandboxSetCurrencyBalanceRequest, brokerAccountId?: string | undefined): Promise<Empty>;
    /**
     * Выставление баланса по инструментным позициям
     * @param body Запрос на выставление баланса по инструментным позициям
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    balance2(body: SandboxSetPositionBalanceRequest, brokerAccountId?: string | undefined): Promise<Empty>;
    /**
     * Удаление счета
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    remove(brokerAccountId?: string | undefined): Promise<Empty>;
    /**
     * Удаление всех позиций
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    clear(brokerAccountId?: string | undefined): Promise<Empty>;
}

export class SandboxClient implements ISandboxClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api-invest.tinkoff.ru/openapi/";
    }

    /**
     * Регистрация клиента в sandbox
     * @param body (optional) Запрос на создание счета и выставление баланса по валютным позициям
     * @return Успешный ответ
     */
    register(body?: SandboxRegisterRequest | undefined, signal?: AbortSignal | undefined): Promise<SandboxRegisterResponse> {
        let url_ = this.baseUrl + "/sandbox/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<SandboxRegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SandboxRegisterResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SandboxRegisterResponse>(<any>null);
    }

    /**
     * Выставление баланса по валютным позициям
     * @param body Запрос на выставление баланса по валютным позициям
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    balance(body: SandboxSetCurrencyBalanceRequest, brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<Empty> {
        let url_ = this.baseUrl + "/sandbox/currencies/balance?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalance(_response);
        });
    }

    protected processBalance(response: Response): Promise<Empty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Empty>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Empty>(<any>null);
    }

    /**
     * Выставление баланса по инструментным позициям
     * @param body Запрос на выставление баланса по инструментным позициям
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    balance2(body: SandboxSetPositionBalanceRequest, brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<Empty> {
        let url_ = this.baseUrl + "/sandbox/positions/balance?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBalance2(_response);
        });
    }

    protected processBalance2(response: Response): Promise<Empty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Empty>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Empty>(<any>null);
    }

    /**
     * Удаление счета
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    remove(brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<Empty> {
        let url_ = this.baseUrl + "/sandbox/remove?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemove(_response);
        });
    }

    protected processRemove(response: Response): Promise<Empty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Empty>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Empty>(<any>null);
    }

    /**
     * Удаление всех позиций
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    clear(brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<Empty> {
        let url_ = this.baseUrl + "/sandbox/clear?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClear(_response);
        });
    }

    protected processClear(response: Response): Promise<Empty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Empty>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Empty>(<any>null);
    }
}

export interface IOrdersClient {
    /**
     * Получение списка активных заявок
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Список заявок
     */
    orders(brokerAccountId?: string | undefined): Promise<OrdersResponse>;
    /**
     * Создание лимитной заявки
     * @param figi FIGI инструмента
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Созданная заявка
     */
    limitOrder(figi: string, body: LimitOrderRequest, brokerAccountId?: string | undefined): Promise<LimitOrderResponse>;
    /**
     * Создание рыночной заявки
     * @param figi FIGI инструмента
     * @param brokerAccountId (optional) Уникальный идентификатор счета (по умолчанию - Тинькофф)
     * @return Созданная заявка
     */
    marketOrder(figi: string, body: MarketOrderRequest, brokerAccountId?: string | undefined): Promise<MarketOrderResponse>;
    /**
     * Отмена заявки
     * @param orderId ID заявки
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    cancel(orderId: string, brokerAccountId?: string | undefined): Promise<Empty>;
}

export class OrdersClient implements IOrdersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api-invest.tinkoff.ru/openapi/";
    }

    /**
     * Получение списка активных заявок
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Список заявок
     */
    orders(brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<OrdersResponse> {
        let url_ = this.baseUrl + "/orders?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrders(_response);
        });
    }

    protected processOrders(response: Response): Promise<OrdersResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrdersResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrdersResponse>(<any>null);
    }

    /**
     * Создание лимитной заявки
     * @param figi FIGI инструмента
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Созданная заявка
     */
    limitOrder(figi: string, body: LimitOrderRequest, brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<LimitOrderResponse> {
        let url_ = this.baseUrl + "/orders/limit-order?";
        if (figi === undefined || figi === null)
            throw new Error("The parameter 'figi' must be defined and cannot be null.");
        else
            url_ += "figi=" + encodeURIComponent("" + figi) + "&";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLimitOrder(_response);
        });
    }

    protected processLimitOrder(response: Response): Promise<LimitOrderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LimitOrderResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LimitOrderResponse>(<any>null);
    }

    /**
     * Создание рыночной заявки
     * @param figi FIGI инструмента
     * @param brokerAccountId (optional) Уникальный идентификатор счета (по умолчанию - Тинькофф)
     * @return Созданная заявка
     */
    marketOrder(figi: string, body: MarketOrderRequest, brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<MarketOrderResponse> {
        let url_ = this.baseUrl + "/orders/market-order?";
        if (figi === undefined || figi === null)
            throw new Error("The parameter 'figi' must be defined and cannot be null.");
        else
            url_ += "figi=" + encodeURIComponent("" + figi) + "&";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMarketOrder(_response);
        });
    }

    protected processMarketOrder(response: Response): Promise<MarketOrderResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MarketOrderResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketOrderResponse>(<any>null);
    }

    /**
     * Отмена заявки
     * @param orderId ID заявки
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    cancel(orderId: string, brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<Empty> {
        let url_ = this.baseUrl + "/orders/cancel?";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined and cannot be null.");
        else
            url_ += "orderId=" + encodeURIComponent("" + orderId) + "&";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<Empty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Empty>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u041e\u0448\u0438\u0431\u043a\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Empty>(<any>null);
    }
}

export interface IOperationsClient {
    /**
     * Получение списка операций
     * @param from Начало временного промежутка
     * @param to Конец временного промежутка
     * @param figi (optional) Figi инструмента для фильтрации
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Список операций
     */
    operations(from: string, to: string, figi?: string | undefined, brokerAccountId?: string | undefined): Promise<OperationsResponse>;
}

export class OperationsClient implements IOperationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api-invest.tinkoff.ru/openapi/";
    }

    /**
     * Получение списка операций
     * @param from Начало временного промежутка
     * @param to Конец временного промежутка
     * @param figi (optional) Figi инструмента для фильтрации
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Список операций
     */
    operations(from: string, to: string, figi?: string | undefined, brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<OperationsResponse> {
        let url_ = this.baseUrl + "/operations?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (figi === null)
            throw new Error("The parameter 'figi' cannot be null.");
        else if (figi !== undefined)
            url_ += "figi=" + encodeURIComponent("" + figi) + "&";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOperations(_response);
        });
    }

    protected processOperations(response: Response): Promise<OperationsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OperationsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0411\u0440\u043e\u043a\u0435\u0440\u0441\u043a\u0438\u0439 \u0441\u0447\u0435\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationsResponse>(<any>null);
    }
}

export interface IPortfolioClient {
    /**
     * Получение портфеля клиента
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    portfolio(brokerAccountId?: string | undefined): Promise<PortfolioResponse>;
    /**
     * Получение валютных активов клиента
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    currencies(brokerAccountId?: string | undefined): Promise<PortfolioCurrenciesResponse>;
}

export class PortfolioClient implements IPortfolioClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api-invest.tinkoff.ru/openapi/";
    }

    /**
     * Получение портфеля клиента
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    portfolio(brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<PortfolioResponse> {
        let url_ = this.baseUrl + "/portfolio?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPortfolio(_response);
        });
    }

    protected processPortfolio(response: Response): Promise<PortfolioResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortfolioResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0411\u0440\u043e\u043a\u0435\u0440\u0441\u043a\u0438\u0439 \u0441\u0447\u0435\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PortfolioResponse>(<any>null);
    }

    /**
     * Получение валютных активов клиента
     * @param brokerAccountId (optional) Номер счета (по умолчанию - Тинькофф)
     * @return Успешный ответ
     */
    currencies(brokerAccountId?: string | undefined, signal?: AbortSignal | undefined): Promise<PortfolioCurrenciesResponse> {
        let url_ = this.baseUrl + "/portfolio/currencies?";
        if (brokerAccountId === null)
            throw new Error("The parameter 'brokerAccountId' cannot be null.");
        else if (brokerAccountId !== undefined)
            url_ += "brokerAccountId=" + encodeURIComponent("" + brokerAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrencies(_response);
        });
    }

    protected processCurrencies(response: Response): Promise<PortfolioCurrenciesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PortfolioCurrenciesResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0411\u0440\u043e\u043a\u0435\u0440\u0441\u043a\u0438\u0439 \u0441\u0447\u0435\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PortfolioCurrenciesResponse>(<any>null);
    }
}

export interface IUserClient {
    /**
     * Получение брокерских счетов клиента
     * @return Успешный ответ
     */
    accounts(): Promise<UserAccountsResponse>;
}

export class UserClient implements IUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api-invest.tinkoff.ru/openapi/";
    }

    /**
     * Получение брокерских счетов клиента
     * @return Успешный ответ
     */
    accounts(signal?: AbortSignal | undefined): Promise<UserAccountsResponse> {
        let url_ = this.baseUrl + "/user/accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccounts(_response);
        });
    }

    protected processAccounts(response: Response): Promise<UserAccountsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserAccountsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0411\u0440\u043e\u043a\u0435\u0440\u0441\u043a\u0438\u0439 \u0441\u0447\u0435\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserAccountsResponse>(<any>null);
    }
}

export interface IMarketClient {
    /**
     * Получение списка акций
     * @return Успешный ответ
     */
    stocks(): Promise<MarketInstrumentListResponse>;
    /**
     * Получение списка облигаций
     * @return Успешный ответ
     */
    bonds(): Promise<MarketInstrumentListResponse>;
    /**
     * Получение списка ETF
     * @return Успешный ответ
     */
    etfs(): Promise<MarketInstrumentListResponse>;
    /**
     * Получение списка валютных пар
     * @return Успешный ответ
     */
    currencies2(): Promise<MarketInstrumentListResponse>;
    /**
     * Получение стакана по FIGI
     * @param figi FIGI
     * @param depth Глубина стакана [1..20]
     * @return Успешный ответ
     */
    orderbook(figi: string, depth: number): Promise<OrderbookResponse>;
    /**
     * Получение исторических свечей по FIGI
     * @param figi FIGI
     * @param from Начало временного промежутка
     * @param to Конец временного промежутка
     * @param interval Интервал свечи
     * @return Успешный ответ
     */
    candles(figi: string, from: string, to: string, interval: CandleResolution): Promise<CandlesResponse>;
    /**
     * Получение инструмента по FIGI
     * @param figi FIGI
     * @return Успешный ответ
     */
    byFigi(figi: string): Promise<SearchMarketInstrumentResponse>;
    /**
     * Получение инструмента по тикеру
     * @param ticker Тикер инструмента
     * @return Успешный ответ
     */
    byTicker(ticker: string): Promise<MarketInstrumentListResponse>;
}

export class MarketClient implements IMarketClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api-invest.tinkoff.ru/openapi/";
    }

    /**
     * Получение списка акций
     * @return Успешный ответ
     */
    stocks(signal?: AbortSignal | undefined): Promise<MarketInstrumentListResponse> {
        let url_ = this.baseUrl + "/market/stocks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStocks(_response);
        });
    }

    protected processStocks(response: Response): Promise<MarketInstrumentListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MarketInstrumentListResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketInstrumentListResponse>(<any>null);
    }

    /**
     * Получение списка облигаций
     * @return Успешный ответ
     */
    bonds(signal?: AbortSignal | undefined): Promise<MarketInstrumentListResponse> {
        let url_ = this.baseUrl + "/market/bonds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBonds(_response);
        });
    }

    protected processBonds(response: Response): Promise<MarketInstrumentListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MarketInstrumentListResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketInstrumentListResponse>(<any>null);
    }

    /**
     * Получение списка ETF
     * @return Успешный ответ
     */
    etfs(signal?: AbortSignal | undefined): Promise<MarketInstrumentListResponse> {
        let url_ = this.baseUrl + "/market/etfs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEtfs(_response);
        });
    }

    protected processEtfs(response: Response): Promise<MarketInstrumentListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MarketInstrumentListResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketInstrumentListResponse>(<any>null);
    }

    /**
     * Получение списка валютных пар
     * @return Успешный ответ
     */
    currencies2(signal?: AbortSignal | undefined): Promise<MarketInstrumentListResponse> {
        let url_ = this.baseUrl + "/market/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrencies2(_response);
        });
    }

    protected processCurrencies2(response: Response): Promise<MarketInstrumentListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MarketInstrumentListResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketInstrumentListResponse>(<any>null);
    }

    /**
     * Получение стакана по FIGI
     * @param figi FIGI
     * @param depth Глубина стакана [1..20]
     * @return Успешный ответ
     */
    orderbook(figi: string, depth: number, signal?: AbortSignal | undefined): Promise<OrderbookResponse> {
        let url_ = this.baseUrl + "/market/orderbook?";
        if (figi === undefined || figi === null)
            throw new Error("The parameter 'figi' must be defined and cannot be null.");
        else
            url_ += "figi=" + encodeURIComponent("" + figi) + "&";
        if (depth === undefined || depth === null)
            throw new Error("The parameter 'depth' must be defined and cannot be null.");
        else
            url_ += "depth=" + encodeURIComponent("" + depth) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOrderbook(_response);
        });
    }

    protected processOrderbook(response: Response): Promise<OrderbookResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderbookResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderbookResponse>(<any>null);
    }

    /**
     * Получение исторических свечей по FIGI
     * @param figi FIGI
     * @param from Начало временного промежутка
     * @param to Конец временного промежутка
     * @param interval Интервал свечи
     * @return Успешный ответ
     */
    candles(figi: string, from: string, to: string, interval: CandleResolution, signal?: AbortSignal | undefined): Promise<CandlesResponse> {
        let url_ = this.baseUrl + "/market/candles?";
        if (figi === undefined || figi === null)
            throw new Error("The parameter 'figi' must be defined and cannot be null.");
        else
            url_ += "figi=" + encodeURIComponent("" + figi) + "&";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (interval === undefined || interval === null)
            throw new Error("The parameter 'interval' must be defined and cannot be null.");
        else
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCandles(_response);
        });
    }

    protected processCandles(response: Response): Promise<CandlesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CandlesResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CandlesResponse>(<any>null);
    }

    /**
     * Получение инструмента по FIGI
     * @param figi FIGI
     * @return Успешный ответ
     */
    byFigi(figi: string, signal?: AbortSignal | undefined): Promise<SearchMarketInstrumentResponse> {
        let url_ = this.baseUrl + "/market/search/by-figi?";
        if (figi === undefined || figi === null)
            throw new Error("The parameter 'figi' must be defined and cannot be null.");
        else
            url_ += "figi=" + encodeURIComponent("" + figi) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByFigi(_response);
        });
    }

    protected processByFigi(response: Response): Promise<SearchMarketInstrumentResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SearchMarketInstrumentResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchMarketInstrumentResponse>(<any>null);
    }

    /**
     * Получение инструмента по тикеру
     * @param ticker Тикер инструмента
     * @return Успешный ответ
     */
    byTicker(ticker: string, signal?: AbortSignal | undefined): Promise<MarketInstrumentListResponse> {
        let url_ = this.baseUrl + "/market/search/by-ticker?";
        if (ticker === undefined || ticker === null)
            throw new Error("The parameter 'ticker' must be defined and cannot be null.");
        else
            url_ += "ticker=" + encodeURIComponent("" + ticker) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processByTicker(_response);
        });
    }

    protected processByTicker(response: Response): Promise<MarketInstrumentListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MarketInstrumentListResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <ErrorDto>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MarketInstrumentListResponse>(<any>null);
    }
}

export interface Empty {
    trackingId: string;
    payload: any;
    status: string;
}

export interface ErrorDto {
    trackingId: string;
    status: string;
    payload: Payload;
}

export interface PortfolioResponse {
    trackingId: string;
    status: string;
    payload: Portfolio;
}

export interface Portfolio {
    positions: PortfolioPosition[];
}

export interface UserAccountsResponse {
    trackingId: string;
    status: string;
    payload: UserAccounts;
}

export interface UserAccounts {
    accounts: UserAccount[];
}

export interface UserAccount {
    brokerAccountType: BrokerAccountType;
    brokerAccountId: string;
}

export interface PortfolioCurrenciesResponse {
    trackingId: string;
    status: string;
    payload: Currencies;
}

export interface Currencies {
    currencies: CurrencyPosition[];
}

export interface CurrencyPosition {
    currency: Currency;
    balance: number;
    blocked?: number;
}

export interface PortfolioPosition {
    figi: string;
    ticker?: string;
    isin?: string;
    instrumentType: InstrumentType;
    balance: number;
    blocked?: number;
    expectedYield?: MoneyAmount;
    lots: number;
    averagePositionPrice?: MoneyAmount;
    averagePositionPriceNoNkd?: MoneyAmount;
    name: string;
}

export interface MoneyAmount {
    currency: Currency;
    value: number;
}

export interface OrderbookResponse {
    trackingId: string;
    status: string;
    payload: Orderbook;
}

export interface Orderbook {
    figi: string;
    depth: number;
    bids: OrderResponse[];
    asks: OrderResponse[];
    tradeStatus: TradeStatus;
    /** Шаг цены */
    minPriceIncrement: number;
    /** Номинал для облигаций */
    faceValue?: number;
    lastPrice?: number;
    closePrice?: number;
    /** Верхняя граница цены */
    limitUp?: number;
    /** Нижняя граница цены */
    limitDown?: number;
}

export interface OrderResponse {
    price: number;
    quantity: number;
}

export interface CandlesResponse {
    trackingId: string;
    status: string;
    payload: Candles;
}

export interface Candles {
    figi: string;
    interval: CandleResolution;
    candles: Candle[];
}

export interface Candle {
    figi: string;
    interval: CandleResolution;
    o: number;
    c: number;
    h: number;
    l: number;
    v: number;
    /** ISO8601 */
    time: string;
}

export interface OperationsResponse {
    trackingId: string;
    status: string;
    payload: Operations;
}

export interface Operations {
    operations: Operation[];
}

export interface OperationTrade {
    tradeId: string;
    /** ISO8601 */
    date: string;
    price: number;
    quantity: number;
}

export interface Operation {
    id: string;
    status: OperationStatus;
    trades?: OperationTrade[];
    commission?: MoneyAmount;
    currency: Currency;
    payment: number;
    price?: number;
    /** Число инструментов в выставленной заявке */
    quantity?: number;
    /** Число инструментов, исполненных в заявке */
    quantityExecuted?: number;
    figi?: string;
    instrumentType?: InstrumentType;
    isMarginCall: boolean;
    /** ISO8601 */
    date: string;
    operationType?: OperationTypeWithCommission;
}

export interface OrdersResponse {
    trackingId: string;
    status: string;
    payload: Order[];
}

export interface Order {
    orderId: string;
    figi: string;
    operation: OperationType;
    status: OrderStatus;
    requestedLots: number;
    executedLots: number;
    type: OrderType;
    price: number;
}

export interface LimitOrderRequest {
    lots: number;
    operation: OperationType;
    price: number;
}

export interface LimitOrderResponse {
    trackingId: string;
    status: string;
    payload: PlacedLimitOrder;
}

export interface PlacedLimitOrder {
    orderId: string;
    operation: OperationType;
    status: OrderStatus;
    rejectReason?: string;
    /** Сообщение об ошибке */
    message?: string;
    requestedLots: number;
    executedLots: number;
    commission?: MoneyAmount;
}

export interface MarketOrderRequest {
    lots: number;
    operation: OperationType;
}

export interface MarketOrderResponse {
    trackingId: string;
    status: string;
    payload: PlacedMarketOrder;
}

export interface PlacedMarketOrder {
    orderId: string;
    operation: OperationType;
    status: OrderStatus;
    rejectReason?: string;
    /** Сообщение об ошибке */
    message?: string;
    requestedLots: number;
    executedLots: number;
    commission?: MoneyAmount;
}

export type TradeStatus = "NormalTrading" | "NotAvailableForTrading";

export type OperationType = "Buy" | "Sell";

export type OperationTypeWithCommission = "Buy" | "BuyCard" | "Sell" | "BrokerCommission" | "ExchangeCommission" | "ServiceCommission" | "MarginCommission" | "OtherCommission" | "PayIn" | "PayOut" | "Tax" | "TaxLucre" | "TaxDividend" | "TaxCoupon" | "TaxBack" | "Repayment" | "PartRepayment" | "Coupon" | "Dividend" | "SecurityIn" | "SecurityOut";

/** Статус заявки */
export type OperationStatus = "Done" | "Decline" | "Progress";

/** Интервал свечи и допустимый промежуток запроса: - 1min [1 minute, 1 day] - 2min [2 minutes, 1 day] - 3min [3 minutes, 1 day] - 5min [5 minutes, 1 day] - 10min [10 minutes, 1 day] - 15min [15 minutes, 1 day] - 30min [30 minutes, 1 day] - hour [1 hour, 7 days] - day [1 day, 1 year] - week [7 days, 2 years] - month [1 month, 10 years] */
export type CandleResolution = "1min" | "2min" | "3min" | "5min" | "10min" | "15min" | "30min" | "hour" | "day" | "week" | "month";

/** Статус заявки */
export type OrderStatus = "New" | "PartiallyFill" | "Fill" | "Cancelled" | "Replaced" | "PendingCancel" | "Rejected" | "PendingReplace" | "PendingNew";

/** Тип заявки */
export type OrderType = "Limit" | "Market";

export interface SandboxRegisterRequest {
    brokerAccountType?: BrokerAccountType;
}

export interface SandboxRegisterResponse {
    trackingId: string;
    status: string;
    payload: SandboxAccount;
}

export interface SandboxAccount {
    brokerAccountType: BrokerAccountType;
    brokerAccountId: string;
}

export interface SandboxSetCurrencyBalanceRequest {
    currency: SandboxCurrency;
    balance: number;
}

export interface SandboxSetPositionBalanceRequest {
    figi?: string;
    balance: number;
}

export interface MarketInstrumentListResponse {
    trackingId: string;
    status: string;
    payload: MarketInstrumentList;
}

export interface MarketInstrumentList {
    total: number;
    instruments: MarketInstrument[];
}

export interface SearchMarketInstrumentResponse {
    trackingId: string;
    status: string;
    payload: SearchMarketInstrument;
}

export interface MarketInstrumentResponse {
    trackingId: string;
    status: string;
    payload: MarketInstrument;
}

export interface SearchMarketInstrument {
    figi: string;
    ticker: string;
    isin?: string;
    /** Шаг цены */
    minPriceIncrement?: number;
    lot: number;
    currency?: Currency;
    name: string;
    type: InstrumentType;
}

export interface MarketInstrument {
    figi: string;
    ticker: string;
    isin?: string;
    /** Шаг цены */
    minPriceIncrement?: number;
    lot: number;
    /** Минимальное число инструментов для покупки должно быть не меньше, чем размер лота х количество лотов */
    minQuantity?: number;
    currency?: Currency;
    name: string;
    type: InstrumentType;
}

export type SandboxCurrency = "RUB" | "USD" | "EUR" | "GBP" | "HKD" | "CHF" | "JPY" | "CNY" | "TRY";

export type Currency = "RUB" | "USD" | "EUR" | "GBP" | "HKD" | "CHF" | "JPY" | "CNY" | "TRY";

export type InstrumentType = "Stock" | "Currency" | "Bond" | "Etf";

export type BrokerAccountType = "Tinkoff" | "TinkoffIis";

export interface Payload {
    message?: string;
    code?: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}